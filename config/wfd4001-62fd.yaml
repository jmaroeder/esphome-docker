esphome:
  name: wfd4001-62fd
  friendly_name: WFD4001-62fd
  on_boot:
    - priority: 600
      then:
        - lambda: |-
            if (id(start_up_behavior).state == "off") {
              id(last_state) = false;
            } else if (id(start_up_behavior).state == "on") {
              id(last_state) = true;
            } else {
              if (id(start_up_behavior).state == "toggle") {
                id(last_state) = !id(last_state);
              }
              // PreviousValue and toggle
              id(update_state)->execute(id(last_state));
            }
    - priority: 0
      then:
        - event.trigger:
            id: up_button_event
            event_type: idle
        - event.trigger:
            id: down_button_event
            event_type: idle




# esphome:
#   on_boot:
#     priority: 200
#     then:
#       - event.trigger:
#           id: up_button_event
#           event_type: idle
#       - event.trigger:
#           id: down_button_event
#           event_type: idle



packages:
  # wfd4001: !include common/wfd4001.yaml
  wifi: !include
    file: common/wifi.yaml
    vars:
      static_ip: 192.168.2.25

logger:
  level: VERBOSE


bk72xx:
  board: wb3s

event:
  - platform: template
    id: up_button_event
    name: Up Button
    # device_class: button
    event_types:
      - idle
      - click
      - double_click
      - triple_click
      - quadruple_click
      - long_press
  - platform: template
    id: down_button_event
    name: Down Button
    # device_class: button
    event_types:
      - idle
      - click
      - double_click
      - triple_click
      - quadruple_click
      - long_press




globals:
  - id: up_count
    type: short
  - id: up_last_millis
    type: unsigned long
  - id: down_count
    type: short
  - id: down_last_millis
    type: unsigned long
  - id: last_state
    type: bool
    initial_value: 'false'
    restore_value: true
#   - id: immediate_mode
#     type: bool
#     initial_value: 'false'
#     restore_value: true

script:
  - id: _on_press
    parameters:
      is_down: bool
    mode: restart
    then:
      - lambda: |-
          auto TAG = "script._on_press_1";
          if (id(invert_switch).state) {
            is_down = !is_down;
          }
          ESP_LOGD(TAG, "press %s", is_down ? "down" : "up");
          short *count = is_down ? &id(down_count) : &id(up_count);
          unsigned long *last_millis = is_down ? &id(down_last_millis) : &id(up_last_millis);
          unsigned long now = esphome::millis();
          if (now <= *last_millis + id(button_delay).state) {
            *count = *count + 1;
          } else {
            *count = 1;
          }
          ESP_LOGD(TAG, "count: %d, last_millis: %d, now: %d", *count, *last_millis, now);
          *last_millis = now;
          if (id(immediate_mode).state && *count > 0) {
            auto button_event = is_down ? id(down_button_event) : id(up_button_event);
            switch (*count) {
              case 1:
                if (is_down) {
                  id(light_1).turn_off().perform();
                } else {
                  id(light_1).turn_on().perform();
                }
                button_event->trigger("click");
                break;
              case 2:
                button_event->trigger("double_click");
                break;
              case 3:
                button_event->trigger("triple_click");
                break;
              case 4:
                button_event->trigger("quadruple_click");
                break;
            }
          }
      - delay: !lambda "return id(button_delay).state;"
      - lambda: |-
          auto TAG = "script._on_press_2";
          if (id(invert_switch).state) {
            is_down = !is_down;
          }
          ESP_LOGD(TAG, "first delay %s", is_down ? "down" : "up");
          short *count = is_down ? &id(down_count) : &id(up_count);
          auto button = is_down ? id(down_button) : id(up_button);

          if (!id(immediate_mode).state && *count > 0 && !button->state) {
            auto button_event = is_down ? id(down_button_event) : id(up_button_event);
            switch (*count) {
              case 1:
                if (is_down) {
                  id(light_1).turn_off().perform();
                } else {
                  id(light_1).turn_on().perform();
                }
                button_event->trigger("click");
                break;
              case 2:
                button_event->trigger("double_click");
                break;
              case 3:
                button_event->trigger("triple_click");
                break;
              case 4:
                button_event->trigger("quadruple_click");
                break;
            }
          }
      - delay: !lambda "return id(long_press).state - id(button_delay).state;"
      - lambda: |-
          auto TAG = "script._on_press_3";
          if (id(invert_switch).state) {
            is_down = !is_down;
          }
          ESP_LOGD(TAG, "second delay %s", is_down ? "down" : "up");
          auto button = is_down ? id(down_button) : id(up_button);
          if (button->state) {
            auto button_event = is_down ? id(down_button_event) : id(up_button_event);
            button_event->trigger("long_press");
          }
  - id: _on_release
    parameters:
      is_down: bool
    mode: restart
    then:
      - lambda: |-
          auto TAG = "script._on_release";
          if (id(invert_switch).state) {
            is_down = !is_down;
          }
          ESP_LOGD(TAG, "release %s", is_down ? "down" : "up");
  - id: update_state
    parameters:
      light_state: bool
    then:
      - lambda: |-
          auto TAG = "update_state";
          id(last_state) = light_state;
          ESP_LOGD(TAG, "light_state %b, smart bulb mode %b", light_state, id(smart_bulb_mode).state);
          if (id(smart_bulb_mode).state || light_state) {
            id(relay_1).turn_on();
          } else {
            id(relay_1).turn_off();
          }
  - id: _on_smart_bulb_mode_change
    parameters:
      enabled: bool
    then:
      - lambda: |-
          id(update_state)->execute(id(last_state));
switch:
  - platform: template
    id: immediate_mode
    name: Immediate mode
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: config
  - platform: template
    id: smart_bulb_mode
    name: Smart bulb mode
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    on_turn_on: 
      then:
        - lambda: "id(_on_smart_bulb_mode_change)->execute(true);"
    on_turn_off: 
      then:
        - lambda: "id(_on_smart_bulb_mode_change)->execute(false);"
    entity_category: config
  - platform: template
    id: invert_switch
    name: Invert switch
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    entity_category: config
  
number:
  - platform: template
    id: button_delay
    name: Button delay
    unit_of_measurement: ms
    initial_value: 300
    restore_value: true
    min_value: 0
    max_value: 1000
    step: 50
    optimistic: true
    entity_category: config
  - platform: template
    id: long_press
    name: Long press duration
    unit_of_measurement: ms
    initial_value: 500
    restore_value: true
    min_value: 0
    max_value: 2000
    step: 50
    optimistic: true
    entity_category: config

select:
  - platform: template
    id: start_up_behavior
    name: Start-up behavior
    optimistic: true
    initial_option: PreviousValue
    restore_value: true
    options:
      - 'off'
      - 'on'
      - toggle
      - PreviousValue
    entity_category: config

output:
  - platform: gpio
    id: relay_1
    pin: P26
  - platform: template
    id: template_output_1
    type: binary
    write_action:
      # - lambda: "id(update_state)->execute(state);"
      - lambda: |-
          auto TAG = "template_output_1";
          ESP_LOGD(TAG, "write_action, state: %s", state ? "true" : "false");
          id(update_state)->execute(state);

light:
  - platform: binary
    id: light_1
    name: Light
    output: template_output_1
    # restore_mode: RESTORE_DEFAULT_ON
    restore_mode: ALWAYS_OFF

binary_sensor:
  - platform: status
    id: status_1
  - platform: gpio
    id: up_button
    pin:
      number: P8
      inverted: true
    on_press:
      then:
        # - light.turn_on: light_1
        - lambda: "id(_on_press)->execute(false);"
    on_release:
      then:
        - lambda: "id(_on_release)->execute(false);"

  - platform: gpio
    id: down_button
    pin:
      number: P9
      inverted: true
    on_press:
      then:
        # - light.turn_off: light_1
        - lambda: "id(_on_press)->execute(true);"
    on_release:
      then:
        - lambda: "id(_on_release)->execute(true);"

  - platform: gpio
    id: reset_button
    pin:
      number: P6
      inverted: true
  - platform: gpio
    id: p7
    pin: P7

status_led:
  pin: P24